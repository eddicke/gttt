<!doctype html>
<html>

<head>
    <title>Socket.IO chat</title>

</head>

<body>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <title>A Multiplayer Game</title>
    <canvas id="renderCanvas"></canvas>
    <div>
        <button>hide chatBox</button>
        <ul id="messages"></ul>
    </div>
    <form action="">
        <input id="m" autocomplete="off" /><button>Send</button>
    </form>


    <!------ chatBox ---------->
    <link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
    <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>


    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        #messages {
            height: 200px;
            width: 50%;
            overflow: hidden;
            overflow-y: scroll;
        }

        body {
            font: 13px Helvetica, Arial;
        }

        form {
            background: #000;
            padding: 3px;
            position: fixed;
            bottom: 0;
            width: 100%;
        }

        form input {
            border: 0;
            padding: 10px;
            width: 90%;
            margin-right: .5%;
        }

        form button {
            width: 9%;
            background: rgb(130, 224, 255);
            border: none;
            padding: 10px;
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        #messages li {
            padding: 5px 10px;
        }

        #messages li:nth-child(odd) {
            background: #eee;
        }

        #messages {
            margin-bottom: 40px
        }
    </style>


    <!-- Babylon.js -->
    <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="dist/gui.js"></script>

    <script>
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);

        var gui = document.createElement("script")
        gui.src = "https://cdn.rawgit.com/eddicke/chat-example/master/dist/gui.js";
        document.body.appendChild(gui)

        $(function() {
            var socket = io();
            var user = 0

            //listen to keyboard event
            var movement = {
                up: false,
                down: false,
                left: false,
                right: false
            }
            document.addEventListener('keydown', function(event) {
                switch (event.keyCode) {
                    case 65: // A
                        movement.left = true;
                        break;
                    case 87: // W
                        movement.up = true;
                        break;
                    case 68: // D
                        movement.right = true;
                        break;
                    case 83: // S
                        movement.down = true;
                        break;
                }
            });
            document.addEventListener('keyup', function(event) {
                switch (event.keyCode) {
                    case 65: // A
                        movement.left = false;
                        break;
                    case 87: // W
                        movement.up = false;
                        break;
                    case 68: // D
                        movement.right = false;
                        break;
                    case 83: // S
                        movement.down = false;
                        break;
                }
            });


            //////////////********************TERRAIN SCRIPT********************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
            var url = "https://cdn.rawgit.com/BabylonJS/Extensions/master/DynamicTerrain/dist/babylon.dynamicTerrain.min.js";
            var s = document.createElement("script");
            s.src = url;
            document.head.appendChild(s);

            var url = "https://cdn.rawgit.com/waverider404/game-assets/master/dynamic-terrain(Jerome).js";
            var s2 = document.createElement("script");
            s2.src = url;
            document.head.appendChild(s2);
            //////***********BABYLONJS CODE************|||||||||||||||||
            var createScene = function() {

                // This creates a basic Babylon Scene object (non-mesh)
                var scene = new BABYLON.Scene(engine);

                var camera = new BABYLON.ArcRotateCamera("Camera", 3 * Math.PI / 2, Math.PI / 8, 50, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvas, true);
                camera.setPosition(new BABYLON.Vector3(0, 10 * 2, -20 * 2));
                camera.keysUp = [];
                camera.keysDown = [];
                camera.upperBetaLimit = 1.5
                camera.lowerBetaLimit = .5
                // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
                var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

                // Default intensity is 1. Let's dim the light a small amount
                light.intensity = 0.7;
                //SKYBOX-----------><---------------------------------------------
                //sky
                var skyMaterial = new BABYLON.SkyMaterial("skyMaterial", scene);
                skyMaterial.backFaceCulling = false;
                skyMaterial.turbidity = 1;
                skyMaterial.luminance = 1;
                skyMaterial.inclination = 0.42; // The solar inclination, related to the solar azimuth in interval [0, 1]
                skyMaterial.azimuth = 0.25;
                skyMaterial.useSunPosition = false; // Do not set sun position from azimuth and inclination
                skyMaterial.sunPosition = new BABYLON.Vector3(200, 10, 0);
                skyMaterial.rayleigh = 2; // Represents the sky appearance (globally)
                skyMaterial.isPickable = false
                // The amount of haze particles following the Mie scattering theory
                skyMaterial.mieDirectionalG = 0.98;

                skyMaterial.mieCoefficient = 0.05; // The mieCoefficient in interval [0, 0.1], affects the property skyMaterial.mieDirectionalG

                var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
                skybox.infiniteDistance = true;
                skybox.material = skyMaterial;


                //GUI-INTERFACE-----------------------------------------><-------------------------------------------
		gui.onload = function(){
		var popwind = new GUIWindow()
		var change = true


		function coo(){
    
    		if(change){
        change = false
        console.log("select")
        popwind.alpha = 1
        
    }else if(!change){
        change = true
         popwind.alpha = 0
    console.log("de-select")
    
    }
        }


var button = new GUInterface(8, false, 0.8)
button.interact()
button.switch()
button.clear()

function update(){
var wardrobebutton = button.select(5, "power", coo)

var button2 = new GUInterface(8, true, 120.8, -332)
button2.interact()


var powerupbutton = button2.select(1, "open", coo)
}

scene.registerBeforeRender(update())
		
}

                //PSEUDO-IMPOSTOR--------------------------><-----------------------------
                var sphere = BABYLON.Mesh.CreateBox("sphere1", 4, scene);
                sphere.visibility = 0

                //TERRAIN PROCEDURAL GENERATION---------------------------------------><---------------------------
                //TERRAIN MATERIAL-------------------------------------------------------><----------------------------
                // Create terrain material
                var terrainMaterial = new BABYLON.TerrainMaterial("terrainMaterial", scene);
                terrainMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                terrainMaterial.specularPower = 64;
                terrainMaterial.mixTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/mixMap.png", scene);
                terrainMaterial.diffuseTexture1 = new BABYLON.Texture("https://rawcdn.githack.com/waverider404/game-assets/master/kryptonite-crystal-texture-seamless-free-thumb40.jpg", scene);
                terrainMaterial.diffuseTexture2 = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/rock.png", scene);
                terrainMaterial.diffuseTexture3 = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/grass.png", scene);

                // Bump textures according to the previously set diffuse textures
                terrainMaterial.bumpTexture1 = new BABYLON.Texture("https://rawcdn.githack.com/waverider404/game-assets/master/8158-normal.jpg", scene);
                terrainMaterial.bumpTexture2 = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/rockn.png", scene);
                terrainMaterial.bumpTexture3 = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/grassn.png", scene);

                // Rescale textures according to the terrain
                terrainMaterial.diffuseTexture1.uScale = terrainMaterial.diffuseTexture1.vScale = 10;
                terrainMaterial.diffuseTexture2.uScale = terrainMaterial.diffuseTexture2.vScale = 10;
                terrainMaterial.diffuseTexture3.uScale = terrainMaterial.diffuseTexture3.vScale = 10;

                var grass2 = new BABYLON.StandardMaterial("grass2", scene);
                grass2.bumpTexture = new BABYLON.Texture("https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/terrainmaterial/sandstone_rock_001_NRM.png", scene);
                grass2.diffuseTexture = new BABYLON.Texture("https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/terrainmaterial/sandstone_rock_001_COLOR.png", scene);
                grass2.ambientTexture = new BABYLON.Texture("https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/terrainmaterial/sandstone_rock_001_OCC.png", scene);

                grass2.diffuseTexture.uScale = grass2.diffuseTexture.vScale = 10
                grass2.bumpTexture.uScale = grass2.bumpTexture.vScale = 10
                grass2.ambientTexture.uScale = grass2.ambientTexture.vScale = 10


                //terrain

                var mapSubX = 1000; // point number on X axis
                var mapSubZ = 800; // point number on Z axis
                var seed = 0.3; // seed
                var noiseScale = 0.03; // noise frequency
                var elevationScale = 12.0;
                noise.seed(seed);
                var mapData = new Float32Array(mapSubX * mapSubZ * 3); // 3 float values per point : x, y and z

                //var paths = [];                             // array for the ribbon model
                for (var l = 0; l < mapSubZ; l++) {
                    //var path = [];                          // only for the ribbon
                    for (var w = 0; w < mapSubX; w++) {
                        var x = ((w - mapSubX * 0.5) * 2.0);
                        var z = ((l - mapSubZ * 0.5) * 2.0);
                        var y = noise.simplex2(x * noiseScale, z * noiseScale);
                        y *= (8.5 + y) * y * elevationScale; // let's increase a bit the noise computed altitude

                        mapData[3 * (l * mapSubX + w)] = x * 15;
                        mapData[3 * (l * mapSubX + w) + 1] = y;
                        mapData[3 * (l * mapSubX + w) + 2] = z * 15;

                        //path.push(new BABYLON.Vector3(x, y, z));
                    }
                    //paths.push(path);
                }
                var terrainCreated = false;
                var terrain;

                s.onload = function() {
                    // Dynamic Terrain
                    // ===============
                    var terrainSub = 100; // 20 terrain subdivisions
                    var params = {
                        mapData: mapData, // data map declaration : what data to use ?
                        mapSubX: mapSubX, // how are these data stored by rows and columns
                        mapSubZ: mapSubZ,
                        terrainSub: terrainSub // how many terrain subdivisions wanted
                    }
                    terrain = new BABYLON.DynamicTerrain("t", params, scene);
                    terrain.mesh.material = grass2;
                    terrain.subToleranceX = 10;
                    terrain.subToleranceZ = 5;
                    terrainCreated = true;
                    terrain.update(true);


                }
                //GRASS PROCEDURAL GENERATION--------------------------------><----------------------------------------------
                //GRASS------------><--------------------------
                BABYLON.Effect.ShadersStore["customVertexShader"] =
                    ` 
precision highp float;

// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;

//uniform
uniform float time;
uniform sampler2D heightMap;
uniform mat4 world;
uniform mat4 worldViewProjection;

// Examples of variables passed from vertex to fragment shader
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;


float height(vec2 uv)
{
     vec4 bumpData = texture2D( heightMap, uv );
    
    float vAmount = (bumpData.r * 256.0 + bumpData.g + bumpData.b / 256.0) ;
    return vAmount;
}

void main() {

    vNormal = normal;
    vUv = uv;
    
   
    float speed = 1.4;
    float waveWidth = 3.;
    float waveHeight = .08;
    float t = time * speed*8.;

    float vAmount = height(uv);

  

    vec3 newPosition = position + normal*vec3(vAmount/4.0);

    newPosition.x += (
	    // Add some offset to the waves to make it slightly less regular
	    sin(waveWidth * position.x + t * 1.3) *
	    cos(waveWidth * position.y + t * 0.9) * waveHeight
    ) + (
        // Extra waves to add interest
	    cos(waveWidth * 2.0 * position.x + t * -.3) *
	    sin(waveWidth * 4.0 * position.y + t * 3.9) * ( waveHeight / 2.0 )
    );

vPosition = newPosition;

    gl_Position = worldViewProjection * vec4(newPosition, 1.0);

}
  	 `;

                BABYLON.Effect.ShadersStore["customFragmentShader"] =
                    `
        precision highp float;

uniform sampler2D heightMap;
uniform sampler2D basetexture;


uniform float time;
uniform vec3 color;

// Example varyings passed from the vertex shader
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;
 
float height(vec2 uv)
{
     vec4 bumpData = texture2D( heightMap, uv );
    
    float vAmount = (bumpData.r * 256.0 + bumpData.g + bumpData.b / 256.0) ;
    return vAmount;
}


void main() {
   
   
    vec3 v = vPosition;
     vec4 basecolor = texture2D( basetexture, vUv );
     float noise = height(vUv);
     
if(basecolor.g < .3){
    discard;
}
     if(v.y < 5.){
discard;
    }

       if(v.y < noise*.19){
        basecolor.g = .6*noise;
    }
    if(v.y < noise*5.3){
        basecolor.r = .3;
    }
    gl_FragColor = vec4( basecolor.rgb*.5, 1. );

}
        `;

                var mat = new BABYLON.ShaderMaterial("ball_shader", scene,
                    "custom", {
                        attributes: ["position", "normal", "uv"],
                        uniforms: ["worldViewProjection", "world", "vPositionW", "vNormalW", "time"]
                    });

                var texture = new BABYLON.Texture("https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/thumb_Bowling_grass_pxr128.jpg", scene);
                var normal = new BABYLON.Texture("https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/thumb_Bowling_grass_pxr128.jpg", scene);

                mat.setTexture("basetexture", texture)
                mat.setTexture("heightMap", normal)

                s2.onload = function() {
                    var mapSubX = 36;
                    var mapSubZ = 36;
                    var terrainSub = 150;

                    var mapData = new Float32Array(mapSubX * mapSubZ * 3);
                    for (var l = 0; l < mapSubZ; l++) {
                        for (var w = 0; w < mapSubX; w++) {
                            mapData[3 * (l * mapSubX + w)] = (w - mapSubX * 0.5) * 2.0;
                            mapData[3 * (l * mapSubX + w) + 1] = 0;
                            mapData[3 * (l * mapSubX + w) + 2] = (l - mapSubZ * 0.5) * 2.0;
                        }
                    }
                    var params = {
                        mapData: mapData,
                        mapSubX: mapSubX,
                        mapSubZ: mapSubZ,
                        terrainSub: terrainSub
                    };
                    var GRASSLAND = new BABYLON.DynamicTerrain("terraingrass", params, scene);
                    GRASSLAND.mesh.position.y = -44.0;
                    GRASSLAND.mesh.scaling.y = 5
                    GRASSLAND.mesh.alwaysSelectAsActiveMesh = true
                    GRASSLAND.mesh.material = mat;
                    var threshold = 0
                    scene.onAfterCameraRenderObservable.add(function() {
                        threshold += .02
                        mat.setFloat("time", Math.sin(threshold) + 10)

                    })
                };

                //socket.io events---------------------------------------><--------------------------------------
                socket.emit('new player');
                setInterval(function() {
                    socket.emit('movement', movement);
                }, 1000 / 60);


                socket.on('online', function(data) {
                    console.log(data);
                });

                var shft = new BABYLON.Vector3.Zero();
                //pointer event

                scene.onPointerDown = function(ev, poke) {

                    if (poke.hit) {
                        shft.copyFrom(poke.pickedPoint)
                    }

                }

                //LOCOMOTION------------------------><-----------------------------------------------------------
                var speed = 0
                var rotY = 0
                document.addEventListener("keydown", function(ev) {
                    if (ev.which == 32) { // En avant		
                        speed = -2.5
                    }
                })

                document.addEventListener("keyup", function(ev) {
                    if (ev.which == 32) { // En avant		
                        speed = 0
                    }
                })
                setInterval(function() {
                    rotY = -4.69 - camera.alpha;
                    socket.emit("locomotive", {
                        velocity: speed,
                        rotAxis: rotY
                    })
                }, 1000 / 60)
                //Array of limited players----------------><-------------------------------------------------------------------
                setInterval(function() {
                    socket.emit("camera-follow", shft);
                    socket.emit('shift', shft);
                }, 1000 / 60);



                //CREATE MULTIPLE CAMERAS FOR PLAYERS-------------------><--------------------------
                var cameras = []
                for (var i = 0; i < 20; i++) {
                    var cam = new BABYLON.ArcRotateCamera("newCamera", 3 * Math.PI / 2, Math.PI / 8, 50, BABYLON.Vector3.Zero(), scene);
                    cam.attachControl(canvas, true);
                    cam.setPosition(new BABYLON.Vector3(0, 10, -20));
                    cam.setEnabled(false)
                    cameras.push(cam)
                }

                scene.debugLayer.show();
                //GUI-----------------------------------------------><------------------------------------------------------
                var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
		advancedTexture.renderAtIdealSize = true;
		advancedTexture.idealWidth = 600;
		advancedTexture.idealHeight = 400;
                //CREATE PLAYER LABEL/INDICATOR------------------------------><--------------------------------------------------
                var labels = []
                //CREATE MECHS HOORAY!!-------------------------------------------><----------------------------

                var skeleton;
                var loaded = false
                var loader = BABYLON.SceneLoader.ImportMesh("", "https://rawcdn.githack.com/eddicke/chat-example/master/assets/textures/", "mechy.glb", scene, function(newMeshes, particleSystems, skeletons) {
                    loaded = true

                    newMeshes[0].scaling.set(5, 5, 5);
                    for (var i = 0; i < 20; i++) {
                        for (var k = 0; k < newMeshes.length; k++) {
                            var m = newMeshes[k].createInstance("name" + i)
                            m.scaling.set(1.1, 1.1, 1.1);
                            m.rotation.y = Math.PI;
                            m.position.z = 15 * (i / 4);
                            m.setEnabled(false);
                        }
                    }

                    newMeshes[0].setEnabled(false);
                    var action1 = false
                    document.addEventListener("keydown", function(ev) {
                        if (ev.which == 16) {
                            action1 = true
                            socket.emit("changeActions", action1);
                        }
                    })

                    socket.on('playAnimations', function(actions) {
                        for (var id in actions) {
                            var action = actions[id];
                            if (action.play) {

                                for (var i = 0; i < skeletons.length; i++) {
                                    scene.beginAnimation(skeletons[i], 0, 100, true, 6.0);
                                }
                            }
                        }

                    })
                });
                loader.onMaterialLoaded = function(material) {
                    material.sideOrientation = 1;
                };

                //REFERENCE PLAYER---------------------------------------><-------------------------------------
                var newplayers = []
                for (var i = 0; i < 20; i++) {
                    var player = new BABYLON.Mesh.CreateBox("sphere1", 4, scene);
                    player.setEnabled(false)
                    player.rotation.y = Math.PI;
                    player.visibility = 0
                    newplayers.push(player)
                    var rect1 = new BABYLON.GUI.Rectangle();
                    rect1.width = 0.2;
                    rect1.height = "40px";
                    rect1.cornerRadius = 20;
                    rect1.color = "Orange";
                    rect1.thickness = 1;
                    rect1.alpha = .7
                    rect1.background = "green";
                    advancedTexture.addControl(rect1);

                    var label = new BABYLON.GUI.TextBlock();
                    label.text = "GUEST";
                    rect1.addControl(label);

                    rect1.linkWithMesh(player);
                    rect1.linkOffsetY = -50;
                    rect1.isVisible = false;
                    labels.push(rect1)
                }
                //--------------------------------------><------------------------------------------------------------//
                var cnt = 0
                var pl = []
                var original = []
                var select = 0
                var playerElevation = 7.0;
                var playerAltitude = 0.0;
                var camElevation = 28.0;
                var camAltitude = 0.0;
                var nerd = []
                //direction
                var rotr = 0
                socket.on('directions', function(dirs) {
                    rotr += .05
                    cnt += 1
                    for (var id in dirs) {
                        var dir = dirs[id];

                        if (dir.spawn) {

                            original.push(dir.rnd)
                            console.log("this is random" + dir.rnd);
                            newplayers[dir.rnd].setEnabled(true);

                            //CALL THE MECH TO THE SCENE-------------------><--------------------------------------
                            if (loaded) {
                                labels[dir.rnd].isVisible = true
                                labels[dir.rnd].children[0].text = "G-XXX-" + dir.rnd;
                                scene.meshes.forEach(function(m) {
                                    if (m.name === "name" + dir.rnd) {
                                        m.setEnabled(true)
                                        m.parent = newplayers[dir.rnd]
                                    }
                                })
                            }
                            //MECHIIII-------------------------------------><--------------------------------------
                            var mat = new BABYLON.StandardMaterial("texture2", scene);
                            mat.diffuseColor = new BABYLON.Color3(dir.color.r, dir.color.b, dir.color.g);
                            newplayers[dir.rnd].material = mat;
                            newplayers[dir.rnd].rotation.y = dir.rotY
                            newplayers[dir.rnd].position.copyFrom(dir.lastpos)
                            //CREATE A NICE SMOOTH FOLLOW CAMERA-----------------><----------------------------------------
                            //MAKE THE PLAYER LERP----------------------------------------><-------------------------------------------------

                            //TERRAIN HEIGHTMAP-------------------------><---------------------------------------------------------
                            scene.registerBeforeRender(function() {
                                if (terrainCreated) {
                                    playerAltitude = terrain.getHeightFromMap(newplayers[dir.rnd].position.x, newplayers[dir.rnd].position.z) + playerElevation;
                                    newplayers[dir.rnd].position.y = playerAltitude;
                                    camAltitude = terrain.getHeightFromMap(camera.target.x, camera.target.z) + camElevation;
                                    camera.target.y = camAltitude;

                                }
                            });

                        } else {
                            console.log("Max. player reached, join another room!!");
                        }
                    }
                });
                //SMOOTH CAMERA FOLLOW--------><-----------------------------------
                scene.registerBeforeRender(function() {
                    sphere.rotation.y = rotY
                    sphere.locallyTranslate(new BABYLON.Vector3(0, 0, speed))
                    camera.target.x = sphere.position.x
                    camera.target.z = sphere.position.z
                })
                setInterval(function() {
                    socket.emit("getPosition", sphere.getAbsolutePosition())
                }, 1000 / 60);

                // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
                var ground = BABYLON.Mesh.CreateGround("ground1", 6, 6, 2, scene);    
		   
                return scene;

            };

            // ******************
            // Noise Library : https://github.com/josephg/noisejs/blob/master/perlin.js
            var noise;
            (function(global) {
                var module = noise = {};

                function Grad(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }

                Grad.prototype.dot2 = function(x, y) {
                    return this.x * x + this.y * y;
                };

                Grad.prototype.dot3 = function(x, y, z) {
                    return this.x * x + this.y * y + this.z * z;
                };

                var grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),
                    new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),
                    new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)
                ];

                var p = [151, 160, 137, 91, 90, 15,
                    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
                    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
                    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
                    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
                    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
                    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
                    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
                    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
                    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
                    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
                    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
                    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
                ];
                // To remove the need for index wrapping, double the permutation table length
                var perm = new Array(512);
                var gradP = new Array(512);

                // This isn't a very good seeding function, but it works ok. It supports 2^16
                // different seed values. Write something better if you need more seeds.
                module.seed = function(seed) {
                    if (seed > 0 && seed < 1) {
                        // Scale the seed out
                        seed *= 65536;
                    }

                    seed = Math.floor(seed);
                    if (seed < 256) {
                        seed |= seed << 8;
                    }

                    for (var i = 0; i < 256; i++) {
                        var v;
                        if (i & 1) {
                            v = p[i] ^ (seed & 255);
                        } else {
                            v = p[i] ^ ((seed >> 8) & 255);
                        }

                        perm[i] = perm[i + 256] = v;
                        gradP[i] = gradP[i + 256] = grad3[v % 12];
                    }
                };

                module.seed(0);

                /*
                for(var i=0; i<256; i++) {
                  perm[i] = perm[i + 256] = p[i];
                  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
                }*/

                // Skewing and unskewing factors for 2, 3, and 4 dimensions
                var F2 = 0.5 * (Math.sqrt(3) - 1);
                var G2 = (3 - Math.sqrt(3)) / 6;

                var F3 = 1 / 3;
                var G3 = 1 / 6;

                // 2D simplex noise
                module.simplex2 = function(xin, yin) {
                    var n0, n1, n2; // Noise contributions from the three corners
                    // Skew the input space to determine which simplex cell we're in
                    var s = (xin + yin) * F2; // Hairy factor for 2D
                    var i = Math.floor(xin + s);
                    var j = Math.floor(yin + s);
                    var t = (i + j) * G2;
                    var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
                    var y0 = yin - j + t;
                    // For the 2D case, the simplex shape is an equilateral triangle.
                    // Determine which simplex we are in.
                    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
                    if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
                        i1 = 1;
                        j1 = 0;
                    } else { // upper triangle, YX order: (0,0)->(0,1)->(1,1)
                        i1 = 0;
                        j1 = 1;
                    }
                    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
                    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
                    // c = (3-sqrt(3))/6
                    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
                    var y1 = y0 - j1 + G2;
                    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
                    var y2 = y0 - 1 + 2 * G2;
                    // Work out the hashed gradient indices of the three simplex corners
                    i &= 255;
                    j &= 255;
                    var gi0 = gradP[i + perm[j]];
                    var gi1 = gradP[i + i1 + perm[j + j1]];
                    var gi2 = gradP[i + 1 + perm[j + 1]];
                    // Calculate the contribution from the three corners
                    var t0 = 0.5 - x0 * x0 - y0 * y0;
                    if (t0 < 0) {
                        n0 = 0;
                    } else {
                        t0 *= t0;
                        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
                    }
                    var t1 = 0.5 - x1 * x1 - y1 * y1;
                    if (t1 < 0) {
                        n1 = 0;
                    } else {
                        t1 *= t1;
                        n1 = t1 * t1 * gi1.dot2(x1, y1);
                    }
                    var t2 = 0.5 - x2 * x2 - y2 * y2;
                    if (t2 < 0) {
                        n2 = 0;
                    } else {
                        t2 *= t2;
                        n2 = t2 * t2 * gi2.dot2(x2, y2);
                    }
                    // Add contributions from each corner to get the final noise value.
                    // The result is scaled to return values in the interval [-1,1].
                    return 70 * (n0 + n1 + n2);
                };

                // 3D simplex noise
                module.simplex3 = function(xin, yin, zin) {
                    var n0, n1, n2, n3; // Noise contributions from the four corners

                    // Skew the input space to determine which simplex cell we're in
                    var s = (xin + yin + zin) * F3; // Hairy factor for 2D
                    var i = Math.floor(xin + s);
                    var j = Math.floor(yin + s);
                    var k = Math.floor(zin + s);

                    var t = (i + j + k) * G3;
                    var x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
                    var y0 = yin - j + t;
                    var z0 = zin - k + t;

                    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
                    // Determine which simplex we are in.
                    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
                    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
                    if (x0 >= y0) {
                        if (y0 >= z0) {
                            i1 = 1;
                            j1 = 0;
                            k1 = 0;
                            i2 = 1;
                            j2 = 1;
                            k2 = 0;
                        } else if (x0 >= z0) {
                            i1 = 1;
                            j1 = 0;
                            k1 = 0;
                            i2 = 1;
                            j2 = 0;
                            k2 = 1;
                        } else {
                            i1 = 0;
                            j1 = 0;
                            k1 = 1;
                            i2 = 1;
                            j2 = 0;
                            k2 = 1;
                        }
                    } else {
                        if (y0 < z0) {
                            i1 = 0;
                            j1 = 0;
                            k1 = 1;
                            i2 = 0;
                            j2 = 1;
                            k2 = 1;
                        } else if (x0 < z0) {
                            i1 = 0;
                            j1 = 1;
                            k1 = 0;
                            i2 = 0;
                            j2 = 1;
                            k2 = 1;
                        } else {
                            i1 = 0;
                            j1 = 1;
                            k1 = 0;
                            i2 = 1;
                            j2 = 1;
                            k2 = 0;
                        }
                    }
                    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
                    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
                    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
                    // c = 1/6.
                    var x1 = x0 - i1 + G3; // Offsets for second corner
                    var y1 = y0 - j1 + G3;
                    var z1 = z0 - k1 + G3;

                    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
                    var y2 = y0 - j2 + 2 * G3;
                    var z2 = z0 - k2 + 2 * G3;

                    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
                    var y3 = y0 - 1 + 3 * G3;
                    var z3 = z0 - 1 + 3 * G3;

                    // Work out the hashed gradient indices of the four simplex corners
                    i &= 255;
                    j &= 255;
                    k &= 255;
                    var gi0 = gradP[i + perm[j + perm[k]]];
                    var gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];
                    var gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];
                    var gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];

                    // Calculate the contribution from the four corners
                    var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                    if (t0 < 0) {
                        n0 = 0;
                    } else {
                        t0 *= t0;
                        n0 = t0 * t0 * gi0.dot3(x0, y0, z0); // (x,y) of grad3 used for 2D gradient
                    }
                    var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                    if (t1 < 0) {
                        n1 = 0;
                    } else {
                        t1 *= t1;
                        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
                    }
                    var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                    if (t2 < 0) {
                        n2 = 0;
                    } else {
                        t2 *= t2;
                        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
                    }
                    var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                    if (t3 < 0) {
                        n3 = 0;
                    } else {
                        t3 *= t3;
                        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
                    }
                    // Add contributions from each corner to get the final noise value.
                    // The result is scaled to return values in the interval [-1,1].
                    return 32 * (n0 + n1 + n2 + n3);

                };

                // ##### Perlin noise stuff

                function fade(t) {
                    return t * t * t * (t * (t * 6 - 15) + 10);
                }

                function lerp(a, b, t) {
                    return (1 - t) * a + t * b;
                }

                // 2D Perlin Noise
                module.perlin2 = function(x, y) {
                    // Find unit grid cell containing point
                    var X = Math.floor(x),
                        Y = Math.floor(y);
                    // Get relative xy coordinates of point within that cell
                    x = x - X;
                    y = y - Y;
                    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                    X = X & 255;
                    Y = Y & 255;

                    // Calculate noise contributions from each of the four corners
                    var n00 = gradP[X + perm[Y]].dot2(x, y);
                    var n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
                    var n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
                    var n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);

                    // Compute the fade curve value for x
                    var u = fade(x);

                    // Interpolate the four results
                    return lerp(
                        lerp(n00, n10, u),
                        lerp(n01, n11, u),
                        fade(y));
                };

                // 3D Perlin Noise
                module.perlin3 = function(x, y, z) {
                    // Find unit grid cell containing point
                    var X = Math.floor(x),
                        Y = Math.floor(y),
                        Z = Math.floor(z);
                    // Get relative xyz coordinates of point within that cell
                    x = x - X;
                    y = y - Y;
                    z = z - Z;
                    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                    X = X & 255;
                    Y = Y & 255;
                    Z = Z & 255;

                    // Calculate noise contributions from each of the eight corners
                    var n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);
                    var n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);
                    var n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);
                    var n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);
                    var n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);
                    var n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);
                    var n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);
                    var n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);

                    // Compute the fade curve value for x, y, z
                    var u = fade(x);
                    var v = fade(y);
                    var w = fade(z);

                    // Interpolate
                    return lerp(
                        lerp(
                            lerp(n000, n100, u),
                            lerp(n001, n101, u), w),
                        lerp(
                            lerp(n010, n110, u),
                            lerp(n011, n111, u), w),
                        v);
                };

            })(this);

            // ######################################################


            var scene = createScene()

            engine.runRenderLoop(function() {
                if (scene) {
                    scene.render();
                }
            });

            // Resize
            window.addEventListener("resize", function() {
                engine.resize();
            });

            //CHATBOX---------------><-----------------------------------------------

            $('form').submit(function() {
                socket.emit('chat message', $('#m').val());
                $('#m').val('');
                return false;
            });
            socket.on('chat message', function(msg) {
                console.log(msg);
                $('#messages').append($('<li>').text(msg));
                window.scrollTo(0, document.body.scrollHeight);
            });
        });
    </script>
</body>

</html>
